## Вебинар_2_Дженерики ##   

## Name convention ##  
E - Element (used extensively by the Java Collections Framework);  
K - Key;  
N - Number;  
T - Type;  
V - Value;  
S, U, V etc. 2nd+ types.  

## Wildcard для спецификации подтипов ##  

Метасимвол (?) - неизвестный тип, совпадает с любым достоверным типом для данного класса.  
На месте (?) может оказаться какой-то из типов, определенных соответствующим
параметризованным типом.
Иногда возникает задача создать дженерик для определенного набора типов.

### Ограничение сверху (extends) ###  

Рассмотрим рабочий код:

~~~Java
public static <T> Double average(List<? extends Number> numbers) {
    var sum = 0.0;
    for (var number : numbers) {
        sum += number.doubleValue();
    }

    return sum / numbers.size();
}
~~~
с помощью <? extends Number> мы указываем, что тип, который может быть передан в метод,
должен быть подтипом Number. Другими словами, мы задаем верхнюю границу для возможных типов,
которые могут быть использованы. Это позволяет работать с любыми типами, которые являются 
наследниками Number (например, Integer, Double, Float и т.д.). Но при этом запрещает передачу
типов, которые не входят в эту иерархию.

### Ограничение снизу (super) ###  

Ограничение снизу применяется, когда мы хотим добавлять элементы в коллекцию, но не хотим ограничиваться
конкретным типом. Например, если у нас есть метод, который добавляет числа в список, мы можем использовать
super, чтобы этот метод мог работать не только с List\<Integer\>, но и с List\<Number> или даже List\<Object\>.

Пример:

~~~Java
public static void addNumbers(List<? super Integer> list) {
    for (int i = 1; i <= 10; i++) {
        list.add(i);
    }
}
~~~

Метод addNumbers() принимает список, который может содержать элементы типа Integer или его супертипы (например,  
Number или Object). Таким образом, мы ограничиваем тип снизу. Это позволяет добавлять целые числа в список,  
даже если он объявлен как List\<Number\> или List\<Object\>.  

~~~Java
var numbers = new ArrayList<Number>();
addNumbers(numbers); // Добавляем целые числа в список Number
System.out.println(numbers); // => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
~~~

Здесь мы передаем список List\<Number\> в метод addNumbers(), и он успешно добавляет в него целые числа.

## Обобщенные методы ##   

Обобщенные методы - это методы, написанные с использованием параметризованного типа. При этом они могут быть как  
членами обобщенного класса, так и необобщенного. Также обобщенными могут быть конструкторы и интерфейсы.  

Схематично:
~~~Java
public static <T> void findValue(T value, T[] values) {
    // поиск значения типа T среди массива значений типа T
};
~~~

## Базовые типы (Raw Types) ##   

Базовые типы - это обобщенные классы без аргументов (без <>). Существуют для совместимости старых версий Java кода с более новыми.  
Использовать не рекомендуется из-за нарушения типовой безопасности: вместо ожидаемого типа подставляется Object.  

## Стирание типов ##   

При компиляции прикладного кода Java все сведения об обобщенных типах удаляются (стираются). Это означает,  
что параметры типа сначала заменяются их ограничивающим типом, которым является тип Object, если никакого  
явного ограничения не указано. Затем выполняется требуемое приведение типов, определяемое аргументами типа,  
для обеспечения совместимости с типами, указанными в этих аргументах. Компилятор также обеспечивает  
эту совместимость типов.  

## Принцип PECS ##   

Для понимания, когда использовать extends, a когда super, необходимо знать принцип PECS (Producer Extends, Consumer Super).  
Если коллекция является источником данных (производителем Producer), используется extends.   
Например, List<? extends Number> подходит для чтения чисел из списка.  

Если необходимо записать числа в коллекцию, то коллекция является приемником данных (потребителем Consumer).   
В этом случае используется super. Например, List<? super Integer> подходит для добавления целых чисел в список.  

Например, вот как выглядит определение метода Collections.copy():  

~~~Java
public static <T> void copy(List<? super T> dest, List<? extends T> src) {
    // Реализация копирования
}
~~~

Здесь dest - это список, который может содержать элементы типа T или его супертипы (потребитель), а src - это список, который  
может содержать элементы типа Т или его подтипы (производитель).  

 
#### Таким образом: ####   

- используя extends, можно работать с коллекциями, которые производят данные;
- используя super, можно работать с коллекциями, которые потребляют данные;


















































