## Вебинар_4_Stream_API ##

Stream API -  это функциональный инструмент, добавленный в Java 8, который позволяет   
упростить и улучшить обработку коллекций данных в декларативном виде.    

С помощью стримов выполняются следующие операции:
* фильтрация;
* сортировка;
* отображение;
* агрегация.

### Stream_API: Основные концепции ###

* Stream - это последовательность элементов данных, которую можно обрабатывать.
* Операции Stream API могут быть промежуточными (intermediate) и терминальными (terminal).   

### Создание Stream ###

#### Из коллекции ####
Поток можно создать из любой коллекции, такой как список или множество, используя метод stream().
```Java
Collection<Integer> list = new ArrayList<>();
Stream<Integer> stream = list.stream();
```

#### Из массива ####
Для создания потока из массива можно воспользоваться методом Arrays.stream().
```Java
int[] numbers = {1, 2, 3};
Stream<Integer> stream = Arrays.stream(numbers).boxed();
//В случае примитивных типов данных, таких как int,
// поток можно дополнительно преобразовать в 
// объектный тип с помощью метода boxed().
```
#### Из строки ####
Для создания потока символов строки используется метод chars(), который возвращает поток типа IntStream.
```Java
String str = "Hello";
IntStream stream = str.chars();
```
#### Из файла ####
Поток можно создать из строк файла с помощью метода Files.lines(). Этот метод считывает файл построчно и возвращает поток строк.
```Java
Path path = Paths.get("file.txt");
Stream stream = Files.lines(path);
```

#### Генерирование ####
Поток можно также создать с помощью метода Stream.generate(), который использует интерфейс Supplier. При каждом вызове Supplier возвращает новое значение. Это удобно для генерации бесконечных потоков данных.
```Java
Stream stream = Stream.generate(() -> new Random().nextInt());
```

#### Билдер ####
Для более гибкого создания потока можно использовать Stream.Builder. Он позволяет поэтапно добавлять элементы в поток, а затем создать поток с помощью метода build().
```Java
Stream.Builder builder = Stream.builder();
builder.add(1);
builder.add(2);
builder.add(3);
Stream stream = builder.build();
```

### Промежуточные операции ###

Промежуточные операции преобразуют один Stream в другой, они ленивые, и ничего не выполняют, 
пока не вызвана терминальная операция.   
Можно выстраивать цепочки из промежуточных операций.
Все элементы проходят через цепочку __последовательно__.   

Примеры промежуточных операций:

* __filter(Predicate\<T\> predicate)__ - фильтрует элементы, оставляя только те, которые удовлетворяют заданному условию.

Пример: Фильтрация списка чисел, оставляя только чётные числа.
```Java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
Stream<Integer> evenNumbersStream = numbers.stream()
        .filter(n -> n % 2 == 0);
evenNumbersStream.forEach(System.out::println); // prints 2, 4, 6, 8, 10
```

* __map(Function\<T, R\> mapper)__ - преобразует каждый элемент потока в другой объект, используя заданную функцию.

Пример: Преобразование строк в их длины.
```Java
List<String> words = Arrays.asList("apple", "banana", "orange", "peach");

Stream<Integer> lengthsStream = words.stream()
    .map(String::length);
lengthsStream.forEach(System.out::println); // prints 5, 6, 6, 5
```

* __flatMap(Function\<T, Stream\<R\>\> mapper)__ - применяет функцию к каждому элементу потока и "разворачивает" результат в новый поток.   
Это особенно полезно для работы с вложенными структурами данных, такими как списки списков.

Пример: Преобразование списка списков в один плоский поток.
```Java
List<List<Integer>> listOfLists = Arrays.asList(
    Arrays.asList(1, 2, 3),
    Arrays.asList(4, 5, 6),
    Arrays.asList(7, 8, 9)
);
Stream<Integer> flattenedStream = listOfLists.stream()
    .flatMap(Collection::stream);
flattenedStream.forEach(System.out::println); // prints 1, 2, 3, 4, 5, 6, 7, 8, 9
```
##### Разница между map() и flatMap(): #####
>Метод map() преобразует каждый элемент потока в новый элемент. В отличие от него, метод flatMap() преобразует каждый элемент в поток   
и затем "разворачивает" все эти потоки в один плоский поток. Это делает flatMap() полезным для работы с вложенными структурами данных,   
такими как списки списков.

* __distinct()__ - удаляет дублирующие элементы из потока.

Пример: Удаление дубликатов из потока чисел.
```Java
List<Integer> numbers = Arrays.asList(1, 2, 3, 2, 1, 4, 5, 3, 5);
List<Integer> uniqueNumbers = numbers.stream()
    .distinct()
    .collect(Collectors.toList());
System.out.println(uniqueNumbers); // prints [1, 2, 3, 4, 5]
```

* __sorted()__ - сортирует элементы в потоке в естественном порядке (для объектов, которые реализуют интерфейс Comparable\<T\>) или используя заданный компаратор.   
Эта операция полезна для сортировки элементов в потоке перед дальнейшими операциями, такими как фильтрация или агрегация.

Пример: Сортировка списка строк в алфавитном порядке.
```Java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
List<String> sortedNames = names.stream()
    .sorted()
    .collect(Collectors.toList());
System.out.println(sortedNames); // prints ["Alice", "Bob", "Charlie", "David"]
```

* __takeWhile(Predicate\<T\> predicate)__ - создает новый поток, который включает элементы исходного потока до тех пор, пока они удовлетворяют указанному условию (Predicate\<T\>).   
Как только условие становится ложным, поток завершается. Если первый элемент не соответствует предикату, возвращается пустой поток.

Пример: Возвращение чисел, меньших 5, из потока чисел.
```Java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
List<Integer> takenNumbers = numbers.stream()
    .takeWhile(n -> n < 5)
    .collect(Collectors.toList());
System.out.println(takenNumbers); // prints [1, 2, 3, 4]
```
>Как только первое несоответствие условию найдено, поток прекращает работу, даже если последующие элементы соответствуют предикату.

* __dropWhile(Predicate\<T\> predicate)__ - возвращает новый поток, исключающий все элементы исходного потока, которые удовлетворяют указанному   
условию (Predicate\<T\>), до тех пор, пока не встретится элемент, не соответствующий условию. Как только первый элемент не удовлетворяет предикату,   
все последующие элементы включаются в новый поток, независимо от того, соответствуют ли они условию.

Пример: Исключение чисел, меньших 5, из потока. В данном примере все числа меньше 5 будут пропущены, а поток начнется с 5.
```Java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
List<Integer> droppedNumbers = numbers.stream()
    .dropWhile(n -> n < 5)
    .collect(Collectors.toList());
System.out.println(droppedNumbers); // prints [5, 6, 7, 8, 9, 10]
```

* __peek(Consumer\<T\> action)__ - выполняет заданное действие над каждым элементом потока, не изменяя сам поток.  Это полезно для таких задач, как логирование,   
отладка или профилирование.

Пример: Логирование элементов потока.
```Java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream()
    .peek(System.out::println)
    .collect(Collectors.toList());
```
>В этом примере метод peek() выводит каждый элемент на консоль, но сам поток и его элементы остаются неизменными.

* __limit(long maxSize)__ - возвращает новый поток, содержащий не более n элементов исходного потока. Если исходный поток содержит меньше элементов,   
поток будет содержать все доступные элементы. Этот метод полезен для ограничения размера выборки.

Пример: Ограничение потока до первых пяти элементов.
```Java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
List<Integer> limitedNumbers = numbers.stream()
    .limit(5)
    .collect(Collectors.toList());
System.out.println(limitedNumbers); // prints [1, 2, 3, 4, 5]
```

* skip(long n) - возвращает новый поток, исключающий первые n элементов исходного потока. Если исходный поток содержит меньше n элементов, возвращённый   
поток будет пустым. Этот метод удобен, если нужно пропустить определённое количество элементов в начале потока.

Пример: Пропуск первых пяти элементов потока.
```Java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
List<Integer> skippedNumbers = numbers.stream()
    .skip(5)
    .collect(Collectors.toList());
System.out.println(skippedNumbers); // prints [6, 7, 8, 9, 10]
```

### Терминальные операции ###

Терминальные методы в Stream API запускают обработку потока и завершают его. После их вызова поток больше не может быть использован.   
Рассмотрим основные терминальные методы, часто используемые в Java.   

* __forEach(Consumer<T> accept)__ - применяет переданную функцию (объект интерфейса Consumer) к каждому элементу потока.

>Не рекомендуется использовать в продакшене, так как он не возвращает результат, а работает только за счёт "побочных эффектов".   
>Это делает его неудобным и потенциально проблемным при параллельном выполнении потоков, где могут возникнуть сложности с синхронизацией.
>
>Пример плохого использования forEach():
>```Java
>public int getSum (Stream<Integer> s) {
>int [] sum = new int [1];
>s.forEach ( i -> sum [0] += i);
>return sum [0];
>}
>```
>Никогда так не делайте. Этот пример показывает побочный эффект: модификацию внешнего состояния (sum[0]).  
>Если применить параллельное выполнение, возникнут проблемы синхронизации, так как несколько потоков могут  
>одновременно изменять один и тот же элемент массива, что приведёт к некорректным результатам.  

* __сollect(Collector\<T, A, R\> collector)__ — это один из самых полезных и часто используемых терминальных методов. Он применяется для преобразования элементов   
потока в определённую структуру данных (например, List, Set, Map), строку или агрегированное значение.

```Java
  Stream<String> stream = Stream.of("Alice", "Bob", "Charlie");
  List<String> list = stream.collect(Collectors.toList());
  System.out.println(list); // выводит [Alice, Bob, Charlie]
```
Метод collect() собирает элементы в список, но он может быть настроен для сбора данных в любые другие структуры, такие как множества или строки.   
Этот метод принимает объект типа Collector, который определяет, как именно будут собраны элементы.   

Класс __Collectors__ содержит набор предопределённых статических методов для выполнения общих операций, таких как преобразование элементов в списки, множества и другие структуры данных.   
Некоторые популярные __методы класса Collectors__:

* __toList()__: Возвращает коллектор, который собирает элементы в список.
* __toSet()__: Собирает элементы в множество.
* __joining()__: Объединяет элементы потока в одну строку.
* __counting()__: Подсчитывает количество элементов в потоке.

Следующий пример показывает, как можно создать собственный коллектор, который накапливает элементы в список. В данном случае используется лямбда-выражение для определения поведения коллектора.   

```Java
Stream<?> stream;
List<?> list = stream.collect(Collectors.toList());
//Коллектор выше аналогичен данному коду
list = stream.collect(
    () -> new ArrayList<>(), // определяем структуру
    (list, t) -> list.add(t), // определяем, как добавлять элементы
    (l1, l2) -> l1.addAll(l2) // и как объединять две структуры в одну
);
```
* __Optional\<T\> findFirst()__ - возвращает первый элемент потока в виде Optional<T>. Этот метод полезен, когда важно получить именно первый элемент (например, при упорядоченном потоке),   
обычно в сочетании с фильтрацией.

Пример: Извлечение первого элемента, удовлетворяющего условию.
```Java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Optional<Integer> first = numbers.stream()
    .filter(n -> n > 3)
    .findFirst();
System.out.println(first.get()); // выводит 4
```

* __Optional\<T\> findAny()__ - возвращает любой элемент потока в виде Optional<T>. В однопоточных сценариях его поведение идентично findFirst(), но при параллельной обработке потока он может вернуть   
любой элемент, что может улучшить производительность за счёт отсутствия необходимости ожидания первого элемента в последовательности.
findAny() может быть полезен, когда порядок элементов не важен, а нужно просто получить результат как можно быстрее.

* __Optional\<T\> reduce(T identity, BinaryOperator\<T\> accumulator)__ - используется для объединения всех элементов потока в одно итоговое значение. Он отличается от метода collect() тем, что работает с бинарной   
ассоциативной функцией, которая принимает два значения и возвращает одно. reduce() особенно полезен для таких задач, как суммирование, нахождение максимального или минимального значения в потоке.

Пример: Суммирование чисел с помощью reduce().
```Java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Optional<Integer> sum = numbers.stream().reduce((a, b) -> a + b);
System.out.println(sum.get());
```
Метод возвращает Optional<T>, так как поток может быть пустым, и это позволяет избежать ошибок при работе с отсутствующими элементами.
Для упрощения работы можно использовать версию reduce() с начальными значениями, что позволяет избежать работы с Optional.
```Java
int sum = numbers.stream().reduce(0, Integer::sum);
System.out.println(sum); // выводит 15
```

* __anyMatch(Predicate\<T\> predicate)__ - проверяет, соответствует ли хотя бы один элемент потока заданному условию (предикату). Если хотя бы один элемент удовлетворяет предикату,   
возвращается true, иначе — false.

Пример: Проверка, содержит ли поток чётные числа.
```Java
boolean hasEven = numbers.stream().anyMatch(n -> n % 2 == 0);
System.out.println(hasEven); // выводит true
```

* __allMatch(Predicate\<T\> predicate)__ - возвращает true, если все элементы потока удовлетворяют заданному предикату. Если хотя бы один элемент не соответствует предикату, метод возвращает false.

Пример: Проверка, являются ли все элементы потока положительными числами.
```Java
boolean allPositive = numbers.stream().allMatch(n -> n > 0);
System.out.println(allPositive); // выводит true
```

* __toФrray()__ - преобразует элементы потока в массив.
* __min(Comparator\<T\> comparator)__ - находит минимальный элемент в потоке на основе заданного компаратора.
* __max(Comparator\<T\> comparator)__ - находит максимальный элемент в потоке на основе заданного компаратора.
* __count()__ - возвращает количество элементов в потоке. 

### Short-circuiting ###
>Операции “короткого замыкания” в Stream API позволяют прекращать обработку потока данных, как только найден первый подходящий результат, не обрабатывая оставшиеся элементы. Это существенно повышает    
> производительность, особенно при работе с большими потоками, поскольку исключает необходимость обработки всех элементов.
> Примерами операций короткого замыкания могут служить методы anyMatch(), allMatch(), noneMatch(), findFirst(), findAny().
>
>Поведение операций короткого замыкания может меняться в зависимости от того, является поток последовательным или параллельным:
>
> * В последовательных потоках методы, такие как findFirst() или findAny(), возвращают первый элемент по порядку, так как обработка идёт последовательно.
> * В параллельных потоках метод findAny() может вернуть любой элемент, потому что каждый поток обрабатывает свой сегмент данных независимо. Это позволяет завершить работу быстрее, не дожидаясь обработки всех элементов, как в последовательных потоках.

### Группировка элементов ###

Для сложной обработки данных часто требуется группировка элементов по какому-либо признаку. Для этого можно использовать метод collect() вместе с Collectors.groupingBy().   
Этот метод позволяет группировать элементы по различным параметрам, а также производить дополнительные действия над сгруппированными данными.   
Чтобы сгруппировать данные по какому-нибудь признаку, нам надо использовать метод collect() и метод Collectors.groupingBy().

__Группировка по должности (в списки):__
```Java
Map<String, List<Worker>> map1 = workers.stream()
    .collect(Collectors.groupingBy(Worker::getPosition));
```
__Группировка по должности (во множества):__
```Java
Map<String, Set<Worker>> map2 = workers.stream()
    .collect(
        Collectors.groupingBy(
            Worker::getPosition, Collectors.toSet()
        )
    );
```
__Подсчет количества рабочих на каждой должности:__
```Java
Map<String, Long> map3 = workers.stream()
    .collect(
        Collectors.groupingBy(
            Worker::getPosition, Collectors.counting()
        )
    );
```
__Группировка по должности, интересуют только имена:__
```Java
Map<String, Set<String>> map4 = workers.stream()
    .collect(
        Collectors.groupingBy(
            Worker::getPosition,
            Collectors.mapping(
                Worker::getName,
                Collectors.toSet()
            )
        )
    );
```
__Расчет средней зарплаты по должностям:__
```Java
Map<String, Double> map5 = workers.stream()
    .collect(
        Collectors.groupingBy(
            Worker::getPosition,
            Collectors.averagingInt(Worker::getSalary)
        )
    );
```
__Группировка по должности, где имена представлены в виде строки:__
```Java
Map<String, String> map6 = workers.stream()
    .collect(
        Collectors.groupingBy(
            Worker::getPosition,
            Collectors.mapping(
                Worker::getName,
                Collectors.joining(", ", "{","}")
            )
        )
    );
```
__Группировка по должности и возрасту:__
```Java
Map<String, Map<Integer, List<Worker>>> collect = workers.stream()
    .collect(
        Collectors.groupingBy(
            Worker::getPosition,
            Collectors.groupingBy(Worker::getAge)
        )
    );
```




